#!/usr/bin/env ruby
# encoding: utf-8

require 'rubygems'
require 'trollop'
require 'uri'
require "sup/server"

opts = Trollop::options do
  version "sup-server (sup #{Redwood::VERSION})"
  banner <<EOS
Usage:
  sup-server [options]
EOS
  text <<EOS

Other options:
EOS
  opt :listen, "URIs to listen on", :type => :strings, :default => [Redwood::DEFAULT_URI]
  opt :verbose, "Increase verbosity."
  opt :version, "Show version information", :short => :none
end

uris = opts[:listen].map do |l|
  URI.parse(l) rescue Trollop::die "invalid uri #{l.inspect}: #{$!.message}"
end

Actor.current.trap_exit = true

lock = Redwood::Server::IndexLock.new Redwood::Server::BASE_DIR
lock.lock_interactively or exit

begin
  store = Redwood::Server::StorageActor.spawn_link(Redwood::Server::Storage.new Redwood::Server::STORAGE_FN)
  index = Redwood::Server::IndexActor.spawn_link(Redwood::Server::Index.new Redwood::Server::INDEX_FN)
  dispatcher = Redwood::Server::Dispatcher.spawn_link index, store
  listeners = uris.map { |uri| Redwood::Protocol.listen uri, dispatcher }

  Actor.sleep 0.1
  info "ready"
  main = Actor.current
  trap('INT') { main << :die }
  trap('TERM') { main << :die }
  catch(:die) do
    loop do
      Actor.receive do |f|
        f.when(Case[:exit]) do |_,actor,exn|
          error "#{actor.class} died, aborting"
          error exn.inspect
          error "Backtrace:"
          exn.backtrace.each { |frame| error frame }
          Actor.current << :die
        end
        f.die?
        f.unexpected
      end
    end
  end
  info "exiting"
rescue Exception => e
  File.open("sup-exception-log.txt", "w") { |f| f.puts e.message; f.puts e.backtrace }
  raise
ensure
  listeners.each { |q| q << :die } if listeners
  dispatcher << :die if dispatcher
  index << :die if index
  store << :die if store
  Actor.sleep 1 # let other actors clean up
  lock.unlock
  info "finished"
end
