#!/usr/bin/env ruby

require 'uri'
require 'rubygems'
require 'trollop'
require "sup"

opts = Trollop::options do
  version "sup-server (sup #{Redwood::VERSION})"
  banner <<EOS
Usage:
  sup-server [options]
EOS
  text <<EOS

Other options:
EOS
  opt :verbose, "Increase verbosity."
  opt :version, "Show version information", :short => :none
end

Redwood::start
index = Redwood::Index.init

def service s
  begin
    index = Redwood::Index
    c = Redwood::Protocol.new s
    while (x = c.read)
      type, hash, = *x
      tag = hash[:tag]
      puts "#{type}: #{hash.map { |k,v| "#{k}=#{v.inspect}" } * ', '}"
      case type
      when :query
        q = index.parse_query hash[:query]
        fields = hash[:fields] || [:message_id, :subject]
        offset = hash[:offset] || 0
        limit = hash[:limit]
        i = 0
        index.each_id q do |msgid|
          e = Redwood::Index.get_entry msgid
          e[:labels] = e[:labels].to_a
          e.reject! { |k,v| !fields.member? k }
          c.write :document, :tag => tag, :document => e
          i += 1
          break if limit and i >= limit
        end
        c.write :done, :tag => tag
      when :count
        q = index.parse_query hash[:query]
        count = index.num_results_for q
        c.write :integer, :tag => tag, :count => count
      when :modify
      when :add
      when :stream
      when :cancel
      else
        warn "invalid message type #{type}"
      end
    end
  ensure
    s.close
  end
end

index.lock_interactively or exit
begin
  index.load

  srv = TCPServer.new 'localhost', Redwood::Protocol::DEFAULT_PORT
  while (s = srv.accept)
    service s
  end

  index.save
rescue Exception => e
  File.open("sup-exception-log.txt", "w") { |f| f.puts e.backtrace }
  raise
ensure
  Redwood::finish
  index.unlock
end
