#!/usr/bin/env ruby
require 'rubygems'
require 'trollop'
require 'sup/protocol'
require 'pp'
require 'yaml'
include Redwood

SUB_COMMANDS = %w(query count label add stream)
global_opts = Trollop::options do
  #version = "sup-cmd (sup #{Redwood::VERSION})"
  banner <<EOS
Interact with a running sup-server.

Usage:
  sup-cmd [global options] command [options]

  Valid commands: #{SUB_COMMANDS * ', '}

  Global options:
EOS

  opt :host, "Host", :default => 'localhost', :short => 'H'
  opt :port, "Port", :default => Wire::DEFAULT_TCP_PORT, :short => 'P'

  stop_on SUB_COMMANDS
end

cmd = ARGV.shift
cmd_opts = case cmd
when "query"
  Trollop.options do
    opt :offset, "Offset", :default => 0, :type => :int
    opt :limit, "Limit", :type => :int
    opt :raw, "Retrieve raw message text", :default => false
  end
when "count"
  Trollop.options do
  end
when "label"
  Trollop.options do
    opt :add_labels, "Labels to add", :default => ""
    opt :remove_labels, "Labels to remove", :default => ""
  end
when "add"
  Trollop.options do
    opt :labels, "Labels separated by commas", :default => ""
  end
when "stream"
  Trollop.options do
  end
else
  Trollop::die "unrecognized command #{cmd.inspect}"
end

begin
  c = Wire.tcp global_opts[:host], global_opts[:port]
rescue Errno::ECONNREFUSED
  $stderr.puts "Error connecting to server: #{$!.message}"
  exit 1
end

case cmd
when "query"
  query = ARGV.first or fail "query argument required"
  c.write :query,
          :query => query,
          :offset => cmd_opts[:offset],
          :limit => cmd_opts[:limit],
          :raw => cmd_opts[:raw]
  while ((x = c.read) && x.first != :done)
    puts YAML.dump(x[1][:message])
    puts YAML.dump(x[1][:raw]) if cmd_opts[:raw]
  end
when "count"
  query = ARGV.first or fail "query argument required"
  c.write :count,
          :query => query
  type, args, = c.read
  puts args[:count]
when "label"
  query = ARGV.first or fail "query argument required"
  c.write :label,
          :query => query,
          :add => cmd_opts[:add_labels].split(','),
          :remove => cmd_opts[:remove_labels].split(',')
  reply = c.read
  fail "error labelling messages: #{reply.inspect}" unless reply.first == :done
when "add"
  labels = cmd_opts[:labels].split(',')
  while raw = gets(nil)
    c.write :add,
            :raw => raw,
            :labels => labels
    reply = c.read
    fail "error adding message: #{reply.inspect}" unless reply.first == :done
  end
else
  fail "#{cmd} command unimplemented"
end
