#!/usr/bin/env ruby
require 'rubygems'
require 'revactor'
require 'trollop'
require 'sup'
require 'sup/protocol'
require 'sup/sources/mbox'
require 'pp'
require 'yaml'
include Redwood

SUB_COMMANDS = %w(query count label add stream)
global_opts = Trollop::options do
  #version = "sup-cmd (sup #{Redwood::VERSION})"
  banner <<EOS
Interact with a running sup-server.

Usage:
  sup-cmd [global options] command [options]

  Valid commands: #{SUB_COMMANDS * ', '}

  Global options:
EOS

  opt :uri, "URI", :default => Redwood::DEFAULT_URI
  opt :verbose

  stop_on SUB_COMMANDS
end

uri = URI.parse(global_opts[:uri]) rescue Trollop::die("invalid uri #{global_opts[:uri].inspect}: #{$!.message}")

cmd = ARGV.shift
cmd_opts = case cmd
when "query"
  Trollop.options do
    opt :offset, "Offset", :default => 0, :type => :int
    opt :limit, "Limit", :type => :int
    opt :raw, "Retrieve raw message text", :default => false
  end
when "count"
  Trollop.options do
  end
when "label"
  Trollop.options do
    opt :add_labels, "Labels to add", :default => ""
    opt :remove_labels, "Labels to remove", :default => ""
  end
when "add"
  Trollop.options do
    opt :labels, "Labels separated by commas", :default => ""
    opt :mbox, "Treat input files as mboxes", :default => false
  end
when "stream"
  Trollop.options do
    opt :raw, "Retrieve raw message text", :default => false
  end
else
  Trollop::die "unrecognized command #{cmd.inspect}"
end

begin
  c = Protocol.connect uri
rescue Errno::ECONNREFUSED
  $stderr.puts "Error connecting to server: #{$!.message}"
  exit 1
end

case cmd
when "query"
  query = ARGV.first or fail "query argument required"
  c.send :query,
         :query => query,
         :offset => cmd_opts[:offset],
         :limit => cmd_opts[:limit],
         :raw => cmd_opts[:raw]
  while ((x = c.read) && x.first != :done)
    puts YAML.dump(x[1][:message])
    puts YAML.dump(x[1][:raw]) if cmd_opts[:raw]
  end
when "count"
  query = ARGV.first or fail "query argument required"
  c.send :count,
         :query => query
  type, args, = c.read
  puts args[:count]
when "label"
  query = ARGV.first or fail "query argument required"
  c.send :label,
         :query => query,
         :add => cmd_opts[:add_labels].split(','),
         :remove => cmd_opts[:remove_labels].split(',')
  reply = c.read
  fail "error labelling messages: #{reply.inspect}" unless reply.first == :done
when "add"
  ARGF.binmode
  labels = cmd_opts[:labels].split(',')
  get_message = lambda do
    return ARGF.gets(nil) unless cmd_opts[:mbox]
    str = ""
    l = ARGF.gets
    str << l until ARGF.closed? || ARGF.eof? || MBox::is_break_line?(l = ARGF.gets)
    str.empty? ? nil : str
  end
  i_s = i = 0
  t = Time.now
  while raw = get_message[]
    i += 1
    t_d = Time.now - t
    if t_d >= 5
      i_d = i - i_s
      puts "indexed #{i} messages (#{i_d/t_d} m/s)" if global_opts[:verbose]
      t = Time.now
      i_s = i
    end
    c.send :add,
           :raw => raw,
           :labels => labels
    reply = c.read
    fail "error adding message: #{reply.inspect}" unless reply.first == :done
  end
when "stream"
  query = ARGV.first or fail "query argument required"
  c.send :stream,
         :query => query,
         :raw => cmd_opts[:raw]
  while (x = c.read)
    fail unless x.first == :message
    puts YAML.dump(x[1][:message])
    puts YAML.dump(x[1][:raw]) if cmd_opts[:raw]
  end
else
  fail "#{cmd} command unimplemented"
end
