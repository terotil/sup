#!/usr/bin/env ruby
# encoding: utf-8

require 'uri'
require 'rubygems'
require 'trollop'
require "sup"
require 'sup/client'
require 'sup/protocol'
require 'sup/protocol-actors'
require 'sup/source'
require 'sup/source/mbox'
require 'sup/source/mbox/loader'
require 'sup/source/maildir'
require 'sup/server/config'
require 'sup/client/poll'
require 'uri'

require 'sup/logger'
Redwood::Logger.init.add_sink $stderr
include Redwood::LogsStuff

require 'sup/crypto'

P = Redwood::Protocol

PROGRESS_UPDATE_INTERVAL = 15 # seconds

class Float
  def to_s; sprintf '%.2f', self; end
  def to_time_s; infinite? ? "unknown" : super end
end

class Numeric
  def to_time_s
    i = to_i
    sprintf "%d:%02d:%02d", i / 3600, (i / 60) % 60, i % 60
  end
end

class Set
  def to_s; to_a * ',' end
end

def time
  startt = Time.now
  yield
  Time.now - startt
end

opts = Trollop::options do
  version "sup-sync (sup #{Redwood::VERSION})"
  banner <<EOS
Synchronizes the Sup index with one or more message sources by adding
messages, deleting messages, or changing message state in the index as
appropriate.

"Message state" means read/unread, archived/inbox, starred/unstarred,
and all user-defined labels on each message.

"Default source state" refers to any state that a source itself has
keeps about a message. Sup-sync uses this information when adding a
new message to the index. The source state is typically limited to
read/unread, archived/inbox status and a single label based on the
source name. Messages using the default source state are placed in
the inbox (i.e. not archived) and unstarred.

Usage:
  sup-sync [options] <source>*

where <source>* is zero or more source URIs. If no sources are given,
sync from all usual sources. Supported source URI schemes can be seen
by running "sup-add --help".

Options controlling WHICH messages sup-sync operates on:
EOS
  opt :new, "Operate on new messages only. Don't scan over the entire source. (Default.)", :short => :none
  opt :changed, "Scan over the entire source for messages that have been deleted, altered, or moved from another source."
  opt :restored, "Operate only on those messages included in a dump file as specified by --restore which have changed state."
  opt :all, "Operate on all messages in the source, regardless of newness or changedness."
  opt :start_at, "For --changed, --restored and --all, start at a particular offset.", :type => :int

text <<EOS

Options controlling HOW message state is altered:
EOS
  opt :asis, "If the message is already in the index, preserve its state. Otherwise, use default source state. (Default.)", :short => :none
  opt :restore, "Restore message state from a dump file created with sup-dump. If a message is not in this dumpfile, act as --asis.", :type => String, :short => :none
  opt :discard, "Discard any message state in the index and use the default source state. Dangerous!", :short => :none
  opt :archive, "When using the default source state, mark messages as archived.", :short => "-x"
  opt :read, "When using the default source state, mark messages as read."
  opt :extra_labels, "When using the default source state, also apply these user-defined labels (a comma-separated list)", :default => "", :short => :none

text <<EOS

Other options:
EOS
  opt :uri, "URI to connect to", :default => Redwood::DEFAULT_URI
  opt :verbose, "Print message ids as they're processed."
  opt :optimize, "As the final operation, optimize the index."
  opt :all_sources, "Scan over all sources.", :short => :none
  opt :dry_run, "Don't actually modify the index. Probably only useful with --verbose.", :short => "-n"
  opt :version, "Show version information", :short => :none

  conflicts :changed, :all, :new, :restored
  conflicts :asis, :restore, :discard
end
Trollop::die :restored, "requires --restore" if opts[:restored] unless opts[:restore]
if opts[:start_at]
  Trollop::die :start_at, "must be non-negative" if opts[:start_at] < 0
  Trollop::die :start_at, "requires either --changed, --restored or --all" unless opts[:changed] || opts[:restored] || opts[:all]
end

target = [:new, :changed, :all, :restored].find { |x| opts[x] } || :new
op = [:asis, :restore, :discard].find { |x| opts[x] } || :asis

Redwood::SourceManager.init
Redwood::SourceManager.load_sources
Redwood::PollManager.init
Redwood::CryptoManager.init

uri = URI.parse opts[:uri] rescue Trollop::die :uri, "invalid URI: #{$!.message}"
c = P.connect_normal uri

restored_state = if opts[:restore]
  dump = {}
  puts "Loading state dump from #{opts[:restore]}..."
  IO.foreach opts[:restore] do |l|
    l =~ /^(\S+) \((.*?)\)$/ or raise "Can't read dump line: #{l.inspect}"
    mid, labels = $1, $2
    dump[mid] = labels.to_set_of_symbols
  end
  puts "Read #{dump.size} entries from dump file."
  dump
else
  {}
end

seen = {}
begin
  sources = if opts[:all_sources]
    Redwood::SourceManager.sources
  elsif ARGV.empty?
    Redwood::SourceManager.usual_sources
  else
    ARGV.map do |uri|
      Redwood::SourceManager.source_for uri or Trollop::die "Unknown source: #{uri}. Did you add it with sup-add first?"
    end
  end

  ## for all target specifications except for only-new messages, reset the
  ## source to the beginning (or to the user-specified starting point.)
  unless target == :new
    if opts[:start_at]
      Trollop::die :start_at, "can only be used on one source" unless sources.size == 1
      sources.first.seek_to! opts[:start_at]
      sources.first.correct_offset! if sources.first.respond_to?(:correct_offset!)
    else
      sources.each { |s| s.reset! }
    end
  end

  sources.each do |source|
    puts "Scanning #{source}..."
    num_added = num_updated = num_scanned = num_restored = 0
    last_info_time = start_time = Time.now

    source.each_raw do |raw,source_info,source_labels|
      num_scanned += 1
      source_uri = URI.parse 'none://nowhere#offset'
      msgid = nil
      old = nil
=begin
      P.send c, :query, query: "source:#{source_uri}", limit: 1
      while ((x = P.read c) && x.first != :done)
        old = x[1]
      end
=end

      case target
      when :changed
        ## skip this message if we're operating only on changed messages, the
        ## message is in the index, and it's unchanged from what the source is
        ## reporting.
        fail 'unimplemented'
        next if old && URI.parse(old[:source]) == source_uri
      when :restored
        ## skip if we're operating on restored messages, and this one ain't
        fail 'unimplemented'
        next unless restored_state[msgid]
      when :new
        ## nothing to do; we'll consider all messages starting at the start offset, which
        ## hasn't been changed.
      when :all
        ## nothing to do; we'll consider all messages starting at the start offset, which
        ## was reset to the beginning above.
      end

      labels = source_labels + (source.archived? ? [] : [:inbox])

      ## tweak source labels according to commandline arguments if necessary
      labels.delete :inbox if opts[:archive]
      labels.delete :unread if opts[:read]
      labels += opts[:extra_labels].split(', ')

      ## decide what to do based on message labels and the operation we're performing
      dothis = case
      when (op == :restore) && restored_state[msgid]
        if old && (old_labels != labels)
          labels = restored_state[msgid]
          num_restored += 1
          :label
        elsif old.nil?
          labels = restored_state[msgid]
          num_restored += 1
          :add
        else
          # labels are the same; don't do anything
        end
      when op == :discard
        if old && (old_labels != labels)
          :label
        else
          # labels are the same; don't do anything
        end
      else
        ## duplicate behavior of poll mode: if index_state is non-nil, this is a newer
        ## version of an older message, so merge in any new labels except :unread and
        ## :inbox.
        ##
        ## TODO: refactor such that this isn't duplicated
        if old
          labels = old_labels + (labels - [:unread, :inbox])
          :add
        else
          :add
        end
      end

      ## now, actually do the operation
      case dothis
      when :add
        puts "Adding new message #{source}##{source_info} with labels #{labels}" if opts[:verbose]
        unless opts[:dry_run]
          P.write c, :add, :raw => raw, :labels => labels
          P.read c
        end
        num_added += 1
      when :update
        puts "Updating message #{source}##{source_info}; labels #{old_labels} => #{labels}; offset #{old[:source]} => #{source_uri}" if opts[:verbose]
        unless opts[:dry_run]
          P.write c, :add, :raw => raw, :labels => labels
          P.read c
        end
        num_updated += 1
      when :label
        fail 'unimplemented'
        puts "Changing flags for #{source}##{source_info} from #{old_labels} to #{labels}" if opts[:verbose]
        sync_label :source 
        unless opts[:dry_run]
          P.write c, :label, :query => "source:#{source_uri}", :remove => old_labels, :add => labels
          P.read c
        end
        num_updated += 1
      end

      if Time.now - last_info_time > PROGRESS_UPDATE_INTERVAL
        last_info_time = Time.now
        elapsed = last_info_time - start_time
        pctdone = source.respond_to?(:pct_done) ? source.pct_done : 100.0 * (source.cur_offset.to_f - source.start_offset).to_f / (source.end_offset - source.start_offset).to_f
        remaining = (100.0 - pctdone) * (elapsed.to_f / pctdone)
        printf "## read %dm (about %.0f%%) @ %.1fm/s. %s elapsed, about %s remaining\n", num_scanned, pctdone, num_scanned / elapsed, elapsed.to_time_s, remaining.to_time_s
      end
    end

    puts "Scanned #{num_scanned}, added #{num_added}, updated #{num_updated} messages from #{source}."
    puts "Restored state on #{num_restored} (#{100.0 * num_restored / num_scanned}%) messages." if num_restored > 0
  end

rescue Redwood::FatalSourceError => e
  $stderr.puts "Sorry, I couldn't communicate with a source: #{e.message}"
rescue Exception => e
  File.open("sup-exception-log.txt", "w") { |f| f.puts e.backtrace }
  raise
ensure
end
